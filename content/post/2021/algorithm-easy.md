---
title: "leetcode算法简单题笔记"
date: 2021-03-15T16:01:23+08:00
lastmod: 2021-03-15T16:01:23+08:00
draft: false
tags: ["算法", "笔记", "总结"]
categories: ["知识总结"]
author: "clavenzhang"

weight: 1

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
# comment: false
# toc: true
mathjax: true
---
## 前言
算法，一直被认为是编程领域内的明珠。在很长一段时间里，由于错误的认知，觉得工作中实际上用到算法的概率比较小，可能也真的是做业务的时间太长了，整天被进度/bug/交付等内容充斥，能做到快速功能实现和交付，也就没有那么多心思去想其他的东西了。近来稍闲，于是抽点时间刷一刷算法看看，对于我这种大学和研究生阶段都没有经历过ACM，也极少在工作中留意雕琢自己代码的人来说，简单题都是非常费劲的，而且可能年纪上来了，脑子不如年轻那会儿好使。于是，我打算采用多刷几次的策略，同时把这当中一些值得记录的东西写下来，把它真正变成自己的知识。

## 基础算法
枚举、二分查找、贪心算法、递归、深度优先、广度优先和动态规划。

## 概念
**切比雪夫距离**

二维平面中两个点，可以走横竖斜边的情况下，从一个点到另一个点步数最少的就是切比雪夫距离，即：
```
d12 = max(|x1-x2|,|y1-y2|)
```

## 基础排序算法
排序算法两大类：
* 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
* 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

![排序](/blog/2021/sort.png)

## 8、计数排序(Counting Sort)
计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

**算法描述**
* 确定给出待排序数组的最大值和最小值，初始化一个额外的数组空间k，用来存储待排序数组中的数据和频次
* 遍历待排序数组，统计每个数出现的频次，存入数组k中该数对应的位置，遇到重复的数累加
* 顺序遍历数组k，定义一个从0开始的下标，根据频次把数填充回原数组

**动图演示**
![计数排序](/blog/2021/counting.gif)

**代码实现**
```
func countingSort(nums []int) []int {
    //定义一个额外的数组空间，大小是nums里面最大值
    count := [maxVlue+1]int{}
    for _, v := range nums {
        count[v]++
    }
    sortedIndex := 0
    for k, v := range count {
        for v > 0 {
            nums[sortedIndex] = k
            sortedIndex++
            v--
        }
    }
}
```

**算法分析**
计数排序是一个稳定的排序算法。当输入的元素是n个0到k之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

**相关题**
* leetcode 1365题：有多少小于当前数字的数字
