---
title: "leetcode算法简单题笔记"
date: 2021-03-15T16:01:23+08:00
lastmod: 2021-03-15T16:01:23+08:00
draft: true
tags: ["算法", "笔记", "总结"]
categories: ["知识总结"]
author: "clavenzhang"

weight: 1

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
# comment: false
# toc: true
mathjax: true
---
## 前言
算法，一直被认为是编程领域内的明珠。在很长一段时间里，由于错误的认知，觉得工作中实际上用到算法的概率比较小，可能也真的是做业务的时间太长了，整天被进度/bug/交付等内容充斥，能做到快速功能实现和交付，也就没有那么多心思去想其他的东西了。近来稍闲，于是抽点时间刷一刷算法看看，对于我这种大学和研究生阶段都没有经历过ACM，也极少在工作中留意雕琢自己代码的人来说，简单题都是非常费劲的，而且可能年纪上来了，脑子不如年轻那会儿好使。于是，我打算采用多刷几次的策略，同时把这当中一些值得记录的东西写下来，把它真正变成自己的知识。

## 基础算法
枚举、二分查找、贪心算法、递归、深度优先、广度优先和动态规划。

**二分查找**

前提：有序数组，每次都从中间开始，二分找。时间复杂度O(logn).算法的时间复杂度指的是，随着输入的增加，它的运行时间将以什么样的速度增加。

**数组和链表**

数组读取的时间复杂度是O(1)，插入是O(n)；链表读取时间复杂度是O(n)，插入是O(1). 数组和链表分别是随机访问和顺序访问的机制。

**Go的二维数组初始化**

Go对二维数组的支持不是很友好，最早的时候，我按照常规的初始化写法，结果报超过index错误了，如下：
```
matrix := [][]int{}
for i := 0; i < numRows; i++ {
    matrix[i][0] = 1
}
```
这种写法是错误的，原因是，matrix没有长度初始化。所以要改成下面这种：
```
matrix := make([][]int, n)
for i := range matrix {
	matrix[i] = make([]int, n)
}
```
但是这种还是有个问题，对于杨辉三角矩阵，这样初始化出来的矩阵，会在空白的地方填充0。这种情况下的初始化方式是：
```
matrix := [][]int{}
for i := 0; i < numRows; i++ {
    //每一行的元素个数等于行数，即i+1
    row := make([]int, i+1)
    matrix = append(matrix, row)
}
```
也可以这样写：
```
matrix := make([][]int, numRows)
for i := 0; i < numRows; i++ {
    //每一行的元素个数等于行数，即i+1
    matrix[i] = make([]int, i+1)
}
```


**哈希表(hash_table)**

索引机制，检索效率O(1)，都是一一对应的。kv存储，每个key都是唯一的。如果哈希表有键值冲突，那个键对应的就会退化成链表。好的哈希算法会均匀地把值映射到不同的位置，最糟糕的情况下，哈希表会退化成链表，即所有的值都映射在同一个键上面。

避免冲突的两大关键：填装因子和哈希函数。填装因子：哈希表包含的元素数 / 总的位置数，填装因子大于1就意味着没有足够的位置。正常情况下，如果填装因子大于0.7，就要考虑扩充哈希表的位置。而好的哈希函数，则会让元素呈均匀分布。

## 概念
**切比雪夫距离**

二维平面中两个点，可以走横竖斜边的情况下，从一个点到另一个点步数最少的就是切比雪夫距离，即：
```
d12 = max(|x1-x2|,|y1-y2|)
```

**布赖恩-克尼根算法**

快速找出一个二进制数num中的1的个数：常规思路是，右移遍历，然后识别最右边的1。可以采用num % 2或者num & 1的方式判断，直到迭代结束。更快速的算法是，像人类直观统计1的个数那样，跳过里面的0。算法是num和num-1做and计算的时候，最右边等于1的比特会被移除。比如：
```
num = 10001000
num - 1 = 10000111
num & (num - 1) = 10000000
```

**矩阵对角线**

在矩阵对角线上的点满足，x=y或者x+y=len(n)-1，n是矩阵的边长。

**按位取反**

位计算当中需要取反操作的时候，比如1010取反则变成101。它的实现可以通过与当前位数一致的全1异或计算获得，即1010 ^ 1111 = 101，而全1的获得方式是按位数左移，最后减1：
```
func findComplement(num int) int {
    fullBitNum := 1
    tmpNum := num
    for tmpNum > 0 {
        tmpNum >>= 1
        fullBitNum <<= 1
    }
    return num ^ (fullBitNum-1)
}
```

## 技巧

* 双指针/快慢指针/哈希表/逆序遍历等，合理利用内置函数。
* 二叉树结构，最常用的是递归方式，分别算左子树和右子树的结果。
* golang的初始化，最好用make的方式，而不是var。同时，如果直到容量，直接在声明的时候确定大小，然后直接赋值，比append的速度快很多。

链表的找一些节点的时候，由于没有办法在O(1)的时间内遍历节点，所以一般会用到快慢指针，策略是让快指针走完的时候，慢指针能满足一些场景的需求，比如找链表的中间节点。

Golang的内嵌排序函数：sort.Sort()。sort包的底层实现是多种排序的算法，例如快排，插入等等。调用时并不公开，也无需定义用那种算法。sort包内部会根据实际情况，自动选择最高效的排序算法。go语言具体提供了字符串，整形，双精度浮点数的快捷排序。其他的，需要实现sort.interface{}，比如二维数组，详情可以参考：https://zhuanlan.zhihu.com/p/352301583


## 算法题实战

1、两数之和：在一个数组中，找到两个数加起来等于目标target的下标，考察点：哈希表，只需要遍历一遍数组。时间复杂度O(n)，空间复杂度O(n).

具体的做法是：遍历数组，如果遍历到target-num已经在哈希表存在了，表示num可以与前面的某一个数加起来等于target，如果不存在，则将num放进哈希表，并记录index。如下：
```
func twoSum(nums []int, target int) []int {
    hashTable := make(map[int]int)
    for index, num := range nums {
        if p, ok := hashTable[target-num]; ok {
            return []int{p, index}
        }
        hashTable[num] = index
    }
    return nil
}
```

2、有效的括号，即我们正常的逻辑，左右括号成对，且正确闭合。考察点：栈。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串s无效，返回false. 为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。如下：
```
func isValid(s string) bool {
    n := len(s)
    if n % 2 == 1 {
        return false  //奇数，直接返回
    }
    //哈希表存储括号对
    pairs := map[byte]byte {
        ')':'(',
        ']':'[',
        '}':'{',
    }
    //用数组表示栈
    stack := []byte{}
    for i := 0; i < n; i++ {
        if pairs[s[i]] > 0 {  //右括号
            if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] {
                //如果栈为空或者栈顶元素不能匹配，则返回false
                return false
            }
            //匹配成功，出栈
            stack = stack[:len(stack)-1]
        } else {
            //左括号入栈
            stack = append(stack, s[i])
        }
    }
    return len(stack) == 0  //最后，如果栈里面还有元素，则表示没有全部匹配成功
}
```